{
	"isearch_current": 41,
	"items":
	[
		"new_node",
		"this.head",
		"token",
		"select",
		"selectselect",
		"  // base case. array contains a single item\n  if (array.length <= 1) return array;\n\n  // pick random point between start and end of the array\n  let pivot = array[Math.floor(Math.random() * array.length)];\n  let left = [];\n  let right = [];\n  let equal = [];\n\n  for (let index = 0; index < array.length; index++) {\n    // smaller items go on the left\n    if (array[index] < pivot) {\n      left.push(array[index]);\n      // bigger items go on the right\n    } else if (array[index] > pivot) {\n      right.push(array[index]);\n    } else {\n      // similar items are kept apart\n      equal.push(array[index]);\n    }\n  }\n  // recursive call on the left array\n  // concatenate similar items array\n  // concatenate recursive call on the right\n  return quickSort(left).concat(equal).concat(quickSort(right));\n}\n\nfunction mergeSort(array) {\n\n  // array has a single element, return\n  if (array.length === 1) return array;\n  // split array in two\n  array = split(array);\n  let left = array[0];\n  let right = array[1];\n\n  // split left and right arrays\n  // merge the results\n  return merge(mergeSort(left), mergeSort(right));\n}\n\nfunction merge(left, right) {\n  // base\n  let leftIndex = 0;\n  let rightIndex = 0;\n  let output = [];\n\n  // traverse through both left and right arrays\n  while (leftIndex < left.length && rightIndex < right.length) {\n    // compare values\n    if (left[leftIndex] < right[rightIndex]) {\n      // current right element is bigger than current left element\n      output.push(left[leftIndex]);\n      // move to the next left element\n      leftIndex++;\n    } else {\n      // current right element is smaller than current left element\n      output.push(right[rightIndex]);\n      // move to the next right element\n      rightIndex++;\n    }\n  }\n\n  // black magic\n  return output.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));\n}\n\nfunction split(arr) {\n  // array only has one element, return\n  if (arr.length === 1) return arr;\n  // split array into two arrays\n  var left = arr.splice(0, Math.floor(arr.length / 2));\n  var right = [...arr];\n  return [left, right];\n}\n\nfunction selectionSort(array) {\n\n  // traverse array up to but not including the last element\n  for (let index = 0; index < array.length - 1; index++) {\n    // declare auxiliary index\n    let aux_ind = index;\n    // current iterator starts at array[1]\n    for (let curr_ind = index + 1; curr_ind < array.length; curr_ind++) {\n      if (array[curr_ind] < array[aux_ind]) {\n        //\n        aux_ind = curr_ind;\n      }\n    }\n    // initial index\n    if (aux_ind != index) {\n      let swap = array[index];\n      array[index] = array[aux_ind];\n      array[aux_ind] = swap;\n    }\n  }\n  return array;\n}\n\nfunction insertionSort(array) {\n\n  for (let index = 1; index < array.length; index++) {\n    // keep track of current and previous array entry\n    var current = array[index];\n    var previous_index = index - 1;\n    // previous index is valid and array[previous index] is greater than current\n    while (previous_index > -1 && array[previous_index] > current) {\n      // swap _\n      array[previous_index + 1] = array[previous_index];\n      previous_index--;\n    }\n    // swap _\n    array[previous_index + 1] = current;\n  }\n  return array;\n}\n\nfunction bubbleSort(array) {\n\n  // do THIS [array.lenght] times\n  for (let i = 0; i < array.length; i++) {\n    // traverse the entire array\n    for (let index = 0; index < array.length; index++) {\n      // compare index and index+1\n      if (array[index] > array[index + 1]) {\n        // swap\n        let swap = array[index];\n        array[index] = array[index + 1];\n        array[index + 1] = swap;\n      }\n    }\n  }\n  return array;\n}\n\n\n\n\nfunction isAncestor(tree, ancestor, descendant){\n  if(tree[ancestor]){\n    var hijos = tree[ancestor];\n    if(hijos[descendant]){\n      return true\n    }\n    for(let hijo of hijos){\n      if(isAncestor(tree, hijo, descendant)){\n        return true\n      }\n    }\n  }\n  return false;\n}select",
		"select",
		"array",
		"fill",
		"guild",
		"buils",
		"symbol ref",
		"references",
		"ctrl+x",
		"\"\"",
		"\"ctrl+x\", \"j\"",
		"diag",
		"diagno",
		"close",
		"tab",
		"sbp_yank",
		"sbp_yankct",
		"ct",
		"ctrl+shift+",
		"falsetru",
		"ctrl+shift+",
		"ctrl\\+shift+\\w",
		"ctrl+shift",
		"ctrl+shift+",
		"alt+shift+",
		"super+shifta",
		"super+shift",
		"ctrl+j",
		"ctrl+;",
		"ctrl+",
		"ctrl+;",
		"sequence",
		"re.compil",
		"re.com",
		"re.compile",
		"User",
		"tthis",
		"this",
		"  // ",
		"auxiliary",
		"hide_auxiliary_messages",
		"ancestor",
		"tree",
		"descendant",
		"this.head",
		"linkedlist",
		"this.next",
		"vlaue",
		"node",
		"selectio",
		"    ",
		"add",
		"this.headcu",
		"this.head",
		"current",
		"this.head",
		"head",
		"datavalu",
		"new"
	],
}
